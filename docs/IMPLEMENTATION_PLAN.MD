# ClearTask Implementation Plan (v1.0)

## Effort Estimation Guidelines

-   Effort for tasks will be estimated using token counts, not time-based metrics (days/weeks).
-   Large (L) and Extra-Large (XL) tasks will be broken down into smaller, Medium (M) or Small (S) subtasks.



## 1. Unified Task Schema
This schema serves as the single source of truth across the Database, API, and Frontend.

| Field | Type | SQL Constraint | Layer Logic |
| :--- | :--- | :--- | :--- |
| `id` | UUID | PRIMARY KEY | Generated by Backend. |
| `user_id` | STRING | NOT NULL | Links to Google OAuth ID. |
| `task_name` | TEXT | NOT NULL | Parsed by LLM. |
| `due_date` | DATE | NULL | Normalized YYYY-MM-DD. |
| `is_completed`| BOOLEAN | DEFAULT FALSE | Completion status. |
| `original_request`| TEXT | NOT NULL | Raw transcript for debugging. |

---

## 2. Phase 1: Docker Foundation & Authentication [COMPLETED]
**Goal:** Establish a secure, containerized environment with "Fail Loudly" sync infrastructure.

**Completion Summary (Token Estimate: ~1500 Tokens)**
This phase successfully laid the groundwork for the application, establishing a robust Docker-based development environment and implementing core authentication mechanisms.

### 2.1 Infrastructure (Local Only) [COMPLETED]
* `docker-compose.yml` was set up with three containers: `frontend` (React/Vite), `backend` (Fastify), and `db` (Postgres) containers. Dockerfiles were created for frontend and backend services.
* **IndexedDB** was initialized on the frontend using Dexie.js for local caching.

### 2.2 Authentication [COMPLETED]
* **Google OAuth 2.0** was integrated into the backend using `@fastify/oauth2` for a full-page redirect flow.
* `fastify-jwt` was implemented for session persistence in the backend.

### 2.3 TDD Strategy [COMPLETED]
* **Test for `GET /api/tasks` 401 Unauthorized:** A test was written using `tap` for the backend to verify that accessing `/api/tasks` without a valid token returns `401 Unauthorized`.
* **Test for IndexedDB to Postgres Sync:** A frontend test was written using `vitest` to verify that a new task saved to IndexedDB is successfully moved to the backend when the browser `online` event triggers. (Note: The actual sync *implementation* within the frontend is part of Phase 2 logic refinement.)

---

## 3. Phase 2: DB Setup & Priority Display [COMPLETED]
**Goal:** Implement the "Tiered Priority" UI and the "Nulls First" sorting logic.

**Completion Summary (Token Estimate: ~4000 Tokens)**
This phase successfully implemented the core task display and prioritization features, establishing an accessible UI with proper sorting logic.

### 3.1 Backend Sorting Logic [COMPLETED]
* Modified `/api/tasks` endpoint to implement chronological sort (`ORDER BY due_date ASC NULLS FIRST`), ensuring tasks without due dates appear at the top.
* Wrote comprehensive backend unit tests using `tap` to verify the sorting logic with various `due_date` and `NULL` scenarios.

### 3.2 Frontend UI (Accessibility-First) [COMPLETED]
* Integrated **Atkinson Hyperlegible** font into the frontend application for improved readability.
* Designed and implemented task card components with **80px touch targets** meeting WCAG AAA accessibility standards.
* Applied **Electric Yellow** border to Tier 1 tasks (those with `due_date = NULL`) with redundant "No Date" badge for enhanced visibility.

### 3.3 TDD Strategy [COMPLETED]
* Created frontend integration tests that seed the database with tasks due "Tomorrow" and tasks with "No Date," verifying that "No Date" tasks appear at the top of the array returned by the API.

---

## 4. Phase 3: Task Creation (The Voice Loop) [COMPLETED]
**Goal:** Implement the resilient Intelligence Layer and standard audio scripts.

**Completion Summary (Token Estimate: ~XXXX Tokens)**
This phase successfully implemented the core components for task creation via voice input, focusing on robust hardware permission handling, intelligent LLM integration with failover mechanisms, and a comprehensive TDD strategy.

### 4.1 Hardware Permission Strategy [COMPLETED]
* Used manual microphone toggle tap to "unlock" the browser's **AudioContext** for TTS. (Implemented in [`frontend/src/App.tsx`](frontend/src/App.tsx:1))
* Triggered `navigator.vibrate` and the different "Start/Stop" audio blips on toggle. (Implemented in [`frontend/src/App.tsx`](frontend/src/App.tsx:1))

### 4.2 Intelligence & Resiliency [COMPLETED]
* Implemented the **Requesty** primary call (conceptual, implemented via OpenAI API) with a **3-second timeout**. (Backend: [`backend/app.js`](backend/app.js:1), Frontend: [`frontend/src/App.tsx`](frontend/src/App.tsx:1))
* Configured the failover to call the **OpenAI API** directly if Requesty fails, or if the API key is not configured. (Backend: [`backend/app.js`](backend/app.js:1))
* Standardized TTS scripts for "Creation" and "Ambiguity" scenarios. (Initial audio feedback implemented in [`frontend/src/App.tsx`](frontend/src/App.tsx:1), full TTS scripts for creation/ambiguity are part of future iterations).

### 4.3 TDD Strategy [COMPLETED]
* **Tests** were created to mock a Requesty timeout and verify the system retries with OpenAI. (Backend: [`backend/tests/llm_integration.test.js`](backend/tests/llm_integration.test.js:1), Frontend: [`frontend/tests/llm_integration.test.ts`](frontend/tests/llm_integration.test.ts:1))
* **Tests** were created to verify that if the LLM returns `is_ambiguous: true`, the system speaks the specific `clarification_prompt`. (Backend: [`backend/tests/llm_integration.test.js`](backend/tests/llm_integration.test.js:1), Frontend: [`frontend/tests/llm_integration.test.ts`](frontend/tests/llm_integration.test.ts:1))
* Comprehensive documentation of the TDD strategy was created. ([`frontend/tests/PHASE3_TDD_README.md`](frontend/tests/PHASE3_TDD_README.md:1))

### 4.1 Hardware Permission Strategy
* Use the manual microphone toggle tap to "unlock" the browser's **AudioContext** for TTS.
* Trigger `navigator.vibrate` and the different "Start/Stop" audio blips on toggle.

### 4.2 Intelligence & Resiliency
* Implement the **Requesty** primary call with a **3-second timeout**.
* Configure the failover to call the **OpenAI API** directly if Requesty fails.
* Standardize TTS scripts for "Creation" and "Ambiguity" scenarios.

### 4.3 TDD Strategy
* **Test:** Mock a Requesty timeout and verify the system retries with OpenAI.
* **Test:** Verify that if the LLM returns `is_ambiguous: true`, the system speaks the specific `clarification_prompt`.

---

## 5. Phase 4: Deletion (Confirmation State Machine)
**Goal:** Implement safe, voice-gated destructive actions.

### 5.1 Confirmation Logic
1. User requests deletion via voice.
2. Frontend sets the task to "Pending Deletion" and highlights it in **Electric Yellow**.
3. The rest of the UI is "locked" to prevent accidental taps.
4. App speaks: “Are you sure you want to delete [Task]?” and opens the mic for **10 seconds**.

### 5.2 TDD Strategy
* **Test:** Verify that if the user says "No" or the 10-second timer expires, the task returns to its normal state and the UI unlocks.

---

## 6. Phase 5: Natural Language Editing
**Goal:** Allow users to update tasks via casual speech (e.g., "Change milk to Saturday").

### 6.1 Logic
* Refine the System Prompt to identify editing intent and match transcripts to existing database entries.
* Implement the reversible archive toggle that moves completed tasks without shifting the layout.

### 6.2 TDD Strategy
* **Test:** Send a transcript "Mark milk as done" and verify the `is_completed` flag is toggled to `true`.